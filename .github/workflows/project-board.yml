name: Project Board Automation

on:
  issues:
    types: [opened, reopened, closed]
  pull_request:
    types: [opened, reopened, closed, converted_to_draft, ready_for_review]
  pull_request_target:
    types: [opened, reopened, closed]

permissions:
  contents: read
  issues: write
  pull-requests: write
  repository-projects: write

jobs:
  project_automation:
    runs-on: ubuntu-latest
    steps:
      - name: Move to Project Board
        uses: actions/add-to-project@v0.5.0
        with:
          project-url: https://github.com/orgs/AICryptopia/projects/1
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update Project Status
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADD_TO_PROJECT_PAT }}
          script: |
            const getNewStatus = () => {
              if (context.eventName === 'issues') {
                switch (context.payload.action) {
                  case 'opened':
                    return 'Backlog';
                  case 'reopened':
                    return 'In Progress';
                  case 'closed':
                    return 'Done';
                }
              } else if (context.eventName === 'pull_request' || context.eventName === 'pull_request_target') {
                switch (context.payload.action) {
                  case 'opened':
                    return 'In Progress';
                  case 'ready_for_review':
                    return 'In Review';
                  case 'converted_to_draft':
                    return 'In Progress';
                  case 'closed':
                    return context.payload.pull_request.merged ? 'Done' : 'Backlog';
                }
              }
              return null;
            };

            const updateProjectStatus = async () => {
              try {
                const newStatus = getNewStatus();
                if (!newStatus) return;

                const item = context.payload.issue || context.payload.pull_request;
                
                // Get linked issues if this is a PR
                let linkedIssues = [];
                if (context.eventName === 'pull_request' || context.eventName === 'pull_request_target') {
                  const body = item.body || '';
                  const matches = body.match(/(close[sd]?|fix(e[sd])?|resolve[sd]?)\s*:?\s*#(\d+)/gi) || [];
                  linkedIssues = matches.map(match => parseInt(match.match(/\d+/)[0]));
                  
                  // Also check PR title for linked issues
                  const titleMatches = item.title.match(/(close[sd]?|fix(e[sd])?|resolve[sd]?)\s*:?\s*#(\d+)/gi) || [];
                  linkedIssues.push(...titleMatches.map(match => parseInt(match.match(/\d+/)[0])));
                  
                  // Check for "Relates to #X" format
                  const relatesMatches = body.match(/relates\s+to\s*:?\s*#(\d+)/gi) || [];
                  linkedIssues.push(...relatesMatches.map(match => parseInt(match.match(/\d+/)[0])));
                }

                // Function to update a single item's status
                const updateItemStatus = async (itemId, projectId) => {
                  const mutation = `mutation($projectId: ID!, $itemId: ID!, $value: String!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId
                      itemId: $itemId
                      fieldId: "Status"
                      value: { text: $value }
                    }) {
                      projectV2Item {
                        id
                      }
                    }
                  }`;

                  await github.graphql(mutation, {
                    projectId: projectId,
                    itemId: itemId,
                    value: newStatus
                  });
                };

                // Get project info for the current item
                const query = `query($owner: String!, $name: String!, $number: Int!) {
                  repository(owner: $owner, name: $name) {
                    ${context.eventName === 'issues' ? 'issue' : 'pullRequest'}(number: $number) {
                      projectItems(first: 1) {
                        nodes {
                          id
                          project {
                            id
                          }
                        }
                      }
                    }
                  }
                }`;

                const result = await github.graphql(query, {
                  owner: context.repo.owner,
                  name: context.repo.repo,
                  number: item.number
                });

                const projectItem = result.repository[context.eventName === 'issues' ? 'issue' : 'pullRequest']
                  .projectItems.nodes[0];

                if (projectItem) {
                  await updateItemStatus(projectItem.id, projectItem.project.id);
                  console.log(`Updated status for ${context.eventName} #${item.number} to ${newStatus}`);
                }

                // Update linked issues if PR is merged or closed
                if (linkedIssues.length > 0 && context.payload.action === 'closed') {
                  for (const issueNumber of linkedIssues) {
                    try {
                      const linkedQuery = `query($owner: String!, $name: String!, $number: Int!) {
                        repository(owner: $owner, name: $name) {
                          issue(number: $number) {
                            projectItems(first: 1) {
                              nodes {
                                id
                                project {
                                  id
                                }
                              }
                            }
                          }
                        }
                      }`;

                      const linkedResult = await github.graphql(linkedQuery, {
                        owner: context.repo.owner,
                        name: context.repo.repo,
                        number: issueNumber
                      });

                      const linkedProjectItem = linkedResult.repository.issue.projectItems.nodes[0];
                      if (linkedProjectItem) {
                        await updateItemStatus(linkedProjectItem.id, linkedProjectItem.project.id);
                        console.log(`Updated status for linked issue #${issueNumber} to ${newStatus}`);
                      }
                    } catch (error) {
                      console.error(`Error updating linked issue #${issueNumber}:`, error);
                    }
                  }
                }
              } catch (error) {
                console.error('Error updating project status:', error);
              }
            };

            await updateProjectStatus();

      - name: Add Labels
        uses: actions/github-script@v7
        with:
          script: |
            const addLabels = async () => {
              if (context.eventName === 'issues' && context.payload.action === 'opened') {
                const issue = context.payload.issue;
                const title = issue.title.toLowerCase();
                const body = issue.body ? issue.body.toLowerCase() : '';
                const labels = [];

                if (title.startsWith('[feature]')) {
                  labels.push('âœ¨ Type: Feature');
                } else if (title.startsWith('[bug]')) {
                  labels.push('ðŸ› Type: Bug');
                } else if (title.startsWith('[docs]')) {
                  labels.push('ðŸ“š Type: Documentation');
                } else if (title.startsWith('[maintenance]')) {
                  labels.push('ðŸ”§ Type: Maintenance');
                }

                if (title.includes('[high]') || body.includes('priority: high')) {
                  labels.push('ðŸ”¥ Priority: High');
                } else if (title.includes('[medium]') || body.includes('priority: medium')) {
                  labels.push('â° Priority: Medium');
                } else {
                  labels.push('ðŸ“… Priority: Low');
                }

                labels.push('BUILD');

                if (labels.length > 0) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    labels: labels
                  });
                }
              }
            };
            
            await addLabels(); 